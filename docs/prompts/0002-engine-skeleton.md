You are working in https://github.com/prime-builds/prime-cli.git

You have already added:
- ADRs under docs/adr/
- Architecture doc under docs/architecture/
- Prompts under docs/prompts/
- Shared TS contracts under packages/shared/src/
- SQLite schema.sql under packages/engine/src/storage/
- Workflow DSL JSON schema under packages/core/src/dsl/schema.json

Now implement the next step: an enterprise-grade Engine skeleton that can:
1) persist Projects/Chats/Messages/Runs/Steps/Artifacts to SQLite
2) accept typed IPC commands from Electron
3) stream RunEvents back to UI over IPC
4) perform a “dry-run execution” of workflow steps (no real tools)
5) store artifacts generated by dry-run steps on disk + register them in SQLite
6) integrate planner+critic prompt usage as “stubs” (load prompts from docs/prompts), but do NOT call any external LLM yet unless a local stub is used.

Hard constraints:
- Do NOT build UI.
- Do NOT implement real adapters or run real security tools.
- Do NOT introduce heavy security bureaucracy.
- Keep it production-quality: clean types, clear module boundaries, error handling, cancellation support.
- IPC must be typed and isolated (renderer never gets Node access directly).
- Use the shared types from packages/shared as the source of truth.
- Engine must be runnable headless (for tests) without Electron.

Deliverables (must implement all):

A) packages/engine: runnable engine entrypoint
- Create packages/engine/src/index.ts that starts the engine.
- Engine should expose a programmatic API (for tests) AND an IPC surface (for Electron).
- Implement a simple configuration object: dbPath, artifactsDir, logLevel.

B) SQLite storage layer
- Implement a small repository layer (no ORM required).
- Create:
  packages/engine/src/storage/db.ts (open connection, migrations/init using schema.sql)
  packages/engine/src/storage/repos/*.ts for projects/chats/messages/runs/steps/artifacts
- Ensure foreign keys enabled, created_at populated.
- Keep queries minimal and correct.

C) IPC (Electron <-> Engine) as typed contracts
- Under packages/engine/src/ipc/ implement handlers for these operations (using shared types):
  project.create / project.list / project.open
  chat.create / chat.list / chat.sendMessage
  run.start / run.cancel / run.events (event subscription)
  artifact.list / artifact.open (open = return metadata + file path)
- Use a single “request/response” channel pattern plus a separate “events” stream.
- Implement an in-memory subscription map keyed by run_id for events.

D) Run lifecycle + event stream
- Implement RunManager that:
  - creates run rows + step rows
  - emits RunEvents during lifecycle
  - supports cancel
- Event order must be consistent:
  RUN_STARTED -> STEP_STARTED -> STEP_LOG* -> ARTIFACT_WRITTEN* -> STEP_FINISHED -> ... -> RUN_FINISHED (or RUN_FAILED)
- Persist run + step status to SQLite as it progresses.

E) Workflow execution: DRY-RUN only
- Implement an Executor that accepts a workflow JSON (validated against packages/core schema).
- For each step, simulate work:
  - write a small JSON artifact file into artifactsDir (e.g. artifacts/<run_id>/<artifact_name>)
  - register it in artifacts table with hash/size/path/type
  - emit ARTIFACT_WRITTEN event
  - emit STEP_LOG events with structured messages
- Do not call tools. Do not shell out.

F) Planner/Critic integration (prompt assets)
- Implement a PromptLoader that reads docs/prompts/planner-v0.md and critic-v0.md.
- Provide a stub Planner function that returns a trivial 1-step workflow when user sends a message:
  - This is ONLY to wire the flow end-to-end.
  - Planner must NOT invent adapters; if no adapters are registered, planner returns steps:[].
- Store chat messages in SQLite.
- Create a “run from chat” path:
  chat.sendMessage -> store message -> (optional) planner stub -> create run -> executor dry-run -> stream events.

G) Adapter Registry (empty but real)
- Implement AdapterRegistry interface compatible with shared contracts:
  - list adapters
  - get adapter by id
- Provide a placeholder registry with 0 adapters for now.
- Ensure executor does not require adapters for dry-run steps (it can just write artifacts), but it must still validate adapter existence if a step references an adapter (fail run cleanly with RUN_FAILED).

H) Minimal tests
- Add a small test (or two) proving:
  - DB initializes
  - project/chat/message persisted
  - run.start produces events in expected order
  - artifacts are written to disk and registered

I) Developer ergonomics
- Add packages/engine/README.md with how to run engine headless.
- Add npm scripts at repo root or workspace level to run engine tests.

Implementation notes:
- Prefer Node’s built-in modules and minimal dependencies.
- Keep code clean and strongly typed.
- Provide clear error types for IPC replies (error code + message).
- Cancellation: run.cancel should stop further steps quickly and emit RUN_FAILED or RUN_FINISHED with status=cancelled (pick one and document).

Output expectations:
- Produce real code, compile cleanly, tests pass.
- No UI changes in apps/desktop beyond wiring IPC types if strictly required (but avoid touching it).
